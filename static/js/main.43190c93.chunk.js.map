{"version":3,"sources":["Utils/Functions.ts","Components/Explain.tsx","Components/Table.tsx","Utils/Evaluation.ts","Utils/Tokenizer.ts","Utils/Parser.ts","Components/Editor.tsx","App.tsx","Utils/Hooks.ts","Utils/ValueSource.ts","serviceWorker.ts","index.tsx"],"names":["id","Math","random","toString","Explain","result","className","label","children","length","value","map","c","key","Table","table","React","useState","explain","setExplain","useEffect","undefined","columns","h","variants","v","i","values","onClick","rowSpan","binaryOperation","expressions","state","operation","sequence","evaluated","expr","evaluate","e","reduce","binaryOperationReducers","AND","a","b","OR","XOR","EQ","tree","type","expression","name","Error","operators","Map","operatorKeys","Array","from","keys","createTokenStream","code","isWhitespace","text","match","stream","index","previous","charAt","next","this","eof","peek","char","some","createCharStream","cache","seq","token","push","expect","shift","operator","get","ident","has","join","parse","identifiers","Set","tokens","binarySyntax","left","binary","eq","not","notToken","or","add","and","xor","Editor","props","preload","window","location","hash","substring","atob","err","setCode","onChange","cols","rows","currentTarget","btoa","App","setTable","error","setError","initialValue","timeout","handle","useRef","setState","current","clearTimeout","setTimeout","useDebouncedState","segments","variant","done","createGenerator","_table","items","message","Boolean","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.43190c93.chunk.js","sourcesContent":["// A dumb function to generate random IDs for use as keys\r\nexport const id = () => {\r\n  return Math.random().toString(16);\r\n};\r\n","import React from \"react\";\r\nimport { id } from \"../Utils/Functions\";\r\nimport { Result } from \"../Utils/Types\";\r\n\r\ninterface Props {\r\n  result: Result;\r\n}\r\n\r\nconst Explain = ({ result }: Props) => {\r\n  return (\r\n    <ul>\r\n      <li className=\"explain-tree\">\r\n        {result.label} {result.children.length > 0 && ` = ${result.value}`}\r\n        {result.children.length > 0 &&\r\n          result.children.map((c) => <Explain key={id()} result={c} />)}\r\n      </li>\r\n    </ul>\r\n  );\r\n};\r\n\r\nexport default Explain;\r\n","import React from \"react\";\r\nimport { id } from \"../Utils/Functions\";\r\nimport { Result, TruthTable } from \"../Utils/Types\";\r\nimport Explain from \"./Explain\";\r\n\r\ninterface Props {\r\n  table: TruthTable;\r\n}\r\n\r\nconst Table = ({ table }: Props) => {\r\n  const [explain, setExplain] = React.useState<Result>();\r\n\r\n  React.useEffect(() => {\r\n    setExplain(undefined);\r\n  }, [table]);\r\n\r\n  return (\r\n    <table>\r\n      <thead>\r\n        <tr>\r\n          {table.columns.map((h) => (\r\n            <th key={h}>{h}</th>\r\n          ))}\r\n          <th>Result</th>\r\n          <th></th>\r\n        </tr>\r\n      </thead>\r\n      <tbody>\r\n        {table.variants.map((v, i) => (\r\n          <tr key={id()}>\r\n            {table.columns.map((h) => (\r\n              <td key={id()}>{v.values[h]?.toString()}</td>\r\n            ))}\r\n            <td>{v.result.value.toString()}</td>\r\n            <td>\r\n              <button onClick={() => setExplain(v.result)}>?</button>\r\n            </td>\r\n            {i === 0 && (\r\n              <td rowSpan={table.variants.length}>\r\n                {explain && <Explain result={explain} />}\r\n              </td>\r\n            )}\r\n          </tr>\r\n        ))}\r\n      </tbody>\r\n    </table>\r\n  );\r\n};\r\n\r\nexport default Table;\r\n","import { State, Result, Syntax, BinaryOperationReducer } from \"./Types\";\r\n\r\nconst binaryOperation = (\r\n  label: string,\r\n  expressions: Syntax[],\r\n  state: State,\r\n  operation: (a: boolean, b: boolean) => boolean,\r\n  sequence: number\r\n) => {\r\n  // Evaluate each sub-expression first\r\n  const evaluated = expressions.map((expr) => evaluate(expr, state));\r\n  return {\r\n    label,\r\n    children: evaluated,\r\n    // The final value is the result of all the sub-expressions ran through a reducer\r\n    value: evaluated.map((e) => e.value).reduce(operation),\r\n    sequence,\r\n  };\r\n};\r\n\r\n// Reducers for the binary operations\r\nconst binaryOperationReducers: BinaryOperationReducer = {\r\n  AND: (a, b) => a && b, // All values true\r\n  OR: (a, b) => a || b, // At least one value true\r\n  XOR: (a, b) => a !== b, // No values equal\r\n  EQ: (a, b) => a === b, // All values equal\r\n};\r\n\r\nexport const evaluate = (tree: Syntax, state: State): Result => {\r\n  // Is the type any kind of binary operation?\r\n  if (\r\n    tree.type === \"AND\" ||\r\n    tree.type === \"OR\" ||\r\n    tree.type === \"XOR\" ||\r\n    tree.type === \"EQ\"\r\n  ) {\r\n    return binaryOperation(\r\n      tree.type,\r\n      tree.expressions,\r\n      state,\r\n      binaryOperationReducers[tree.type],\r\n      tree.sequence\r\n    );\r\n    // Is the operation unary NOT\r\n  } else if (tree.type === \"NOT\") {\r\n    const result = evaluate(tree.expression, state);\r\n    return {\r\n      label: \"NOT\",\r\n      value: !result.value, // Invert the result\r\n      children: [result],\r\n      sequence: tree.sequence,\r\n    };\r\n    // Is the expression an identifier\r\n  } else if (tree.type === \"IDENT\") {\r\n    return {\r\n      label: `${tree.name} = ${state[tree.name]}`,\r\n      value: state[tree.name], // Extract the value from the current state\r\n      children: [],\r\n      sequence: tree.sequence,\r\n    };\r\n  } else {\r\n    throw new Error(`Unknown type ${tree.type}`);\r\n  }\r\n};\r\n","import { TokenStream, Token, TokenType } from \"./Types\";\r\n\r\ntype CharStream = {\r\n  previous(): string;\r\n  next(): string;\r\n  peek(): string;\r\n  eof(): boolean;\r\n  match(...char: string[]): boolean;\r\n};\r\n\r\nconst createCharStream = (text: string): CharStream => {\r\n  let index = 0;\r\n  return {\r\n    previous() {\r\n      return text.charAt(index - 1);\r\n    },\r\n    next() {\r\n      return this.eof() ? \"\" : text.charAt(index++);\r\n    },\r\n    peek() {\r\n      return this.eof() ? \"\" : text.charAt(index);\r\n    },\r\n    eof() {\r\n      return index >= text.length;\r\n    },\r\n    match(...char: string[]) {\r\n      const next = this.peek();\r\n      if (char.some((c) => c === next)) {\r\n        this.next();\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n  };\r\n};\r\n\r\nconst operators = new Map<string, TokenType>([\r\n  [\"|\", \"OR\"],\r\n  [\"&\", \"AND\"],\r\n  [\"(\", \"LPAREN\"],\r\n  [\")\", \"RPAREN\"],\r\n  [\"!\", \"NOT\"],\r\n  [\"^\", \"XOR\"],\r\n  [\"=\", \"EQ\"],\r\n]);\r\n\r\nconst operatorKeys = Array.from(operators.keys());\r\n\r\nexport const createTokenStream = (code: string): TokenStream => {\r\n  const isWhitespace = (text: string) => {\r\n    return text.length === 0 || text.match(/\\s/);\r\n  };\r\n\r\n  const isIdent = (text: string) => {\r\n    return text.length > 0 && !isWhitespace(text) && !operators.has(text);\r\n  };\r\n\r\n  const stream = createCharStream(code);\r\n  const cache: Token[] = [];\r\n  let seq = 1;\r\n  return {\r\n    eof() {\r\n      return stream.eof() && cache.length === 0;\r\n    },\r\n    match(type: TokenType) {\r\n      const token = this.next();\r\n      const isMatch = token.type === type;\r\n      if (!isMatch) {\r\n        cache.push(token);\r\n        return;\r\n      }\r\n      return token;\r\n    },\r\n    expect<T extends Token>(type: T[\"type\"]): T {\r\n      const token = this.next();\r\n      if (token.type !== type) {\r\n        // TODO: Improve errror message\r\n        throw new Error(`Expected ${type}, found ${token.type}`);\r\n      }\r\n      return token as T;\r\n    },\r\n    next() {\r\n      if (cache.length > 0) {\r\n        return cache.shift() as Token;\r\n      }\r\n\r\n      while (isWhitespace(stream.peek()) && !stream.eof()) {\r\n        stream.next();\r\n      }\r\n\r\n      if (this.eof()) {\r\n        return {\r\n          type: \"EOF\",\r\n          sequence: seq++,\r\n        };\r\n      }\r\n\r\n      if (stream.match(...operatorKeys)) {\r\n        const operator = stream.previous();\r\n        if (operator === \"|\" || operator === \"&\" || operator === \"=\") {\r\n          // Handle ||, &&, and ==\r\n          stream.match(operator);\r\n          if (operator === \"=\") {\r\n            // Also handle ===\r\n            stream.match(operator);\r\n          }\r\n        }\r\n        return {\r\n          type: operators.get(operator) as TokenType,\r\n          sequence: seq++,\r\n        };\r\n      }\r\n\r\n      const ident: string[] = [];\r\n      while (isIdent(stream.peek())) {\r\n        ident.push(stream.next());\r\n      }\r\n      return {\r\n        type: \"IDENT\",\r\n        name: ident.join(\"\"),\r\n        sequence: seq++,\r\n      };\r\n    },\r\n  };\r\n};\r\n","import { createTokenStream } from \"./Tokenizer\";\r\nimport { Syntax, Token, IdentToken, BinaryTokenType } from \"./Types\";\r\n\r\nexport const parse = (code: string) => {\r\n  // Set to track all known identifiers, set ensures that only unique values are tracked\r\n  const identifiers = new Set<string>();\r\n\r\n  // Create stream to extract tokens\r\n  const tokens = createTokenStream(code);\r\n\r\n  const binarySyntax = (\r\n    next: () => Syntax,\r\n    type: BinaryTokenType\r\n  ) => (): Syntax => {\r\n    // Fetch left operand (either an identifier or an operator with a higher precedence)\r\n    const left = next();\r\n\r\n    // Create a binary operation based on the left operand\r\n    const binary = {\r\n      sequence: left.sequence,\r\n      type,\r\n      expressions: [left],\r\n    };\r\n\r\n    // While there are still tokens to be read, and the next token is the same kind of\r\n    // operator that we're trying to process\r\n    while (!tokens.eof() && tokens.match(type)) {\r\n      // Add the operation to the list of operations\r\n      binary.expressions.push(next());\r\n    }\r\n\r\n    // If there's only 1 expression then we didn't actually find the operator we were\r\n    // looking for, so just unwrap the lone expression\r\n    return binary.expressions.length === 1 ? binary.expressions[0] : binary;\r\n  };\r\n\r\n  const ident = (): Syntax => {\r\n    // Is the next token a parenthesis? Then we have a subexpression to parse\r\n    if (tokens.match(\"LPAREN\")) {\r\n      // Start over at the top of the precedence order\r\n      const expr = or();\r\n      // Ensure that there's a closing parenthesis\r\n      tokens.expect<Token>(\"RPAREN\");\r\n      return expr;\r\n    }\r\n\r\n    // Fetch the expected IdentToken and extract necessary information\r\n    const { name, sequence } = tokens.expect<IdentToken>(\"IDENT\");\r\n\r\n    // Track the identifier\r\n    identifiers.add(name);\r\n\r\n    return {\r\n      type: \"IDENT\",\r\n      name,\r\n      sequence,\r\n    };\r\n  };\r\n\r\n  const not = (): Syntax => {\r\n    // Is the next token an inversion?\r\n    const notToken = tokens.match(\"NOT\");\r\n    if (notToken) {\r\n      // Recursively read NOT expressions until we find an identifier (or a sub-expression)\r\n      return {\r\n        type: \"NOT\",\r\n        expression: not(),\r\n        sequence: notToken.sequence,\r\n      };\r\n    }\r\n\r\n    // No inversion, just return an identifier\r\n    return ident();\r\n  };\r\n\r\n  const eq = binarySyntax(not, \"EQ\");\r\n  const and = binarySyntax(eq, \"AND\");\r\n  const xor = binarySyntax(and, \"XOR\");\r\n  const or = binarySyntax(xor, \"OR\");\r\n\r\n  // Start at the top (or bottom, methods are called in ascending order of precedence OR > XOR > AND > NOT > PARENTHESIS > IDENTIFIER)\r\n  const tree = or();\r\n\r\n  // We're only dealing with a single expression at once, so we should find an EOF here,\r\n  // but let's make sure\r\n  tokens.expect<Token>(\"EOF\");\r\n\r\n  return {\r\n    tree,\r\n    identifiers: Array.from(identifiers),\r\n  };\r\n};\r\n","import * as React from \"react\";\r\n\r\ninterface Props {\r\n  onChange: (value: string) => void;\r\n}\r\n\r\nconst Editor = (props: Props) => {\r\n  const [code, setCode] = React.useState(() => {\r\n    try {\r\n      const preload = window.location.hash.substring(1);\r\n      return preload ? window.atob(preload) : \"\";\r\n    } catch (err) {\r\n      // TODO: Error handling\r\n      window.location.hash = \"\";\r\n      return \"\";\r\n    }\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    props.onChange(code);\r\n  }, [props, code]);\r\n\r\n  const updateCode = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n    const {\r\n      currentTarget: { value },\r\n    } = e;\r\n    window.location.hash = window.btoa(value);\r\n    setCode(value);\r\n  };\r\n  return (\r\n    <textarea cols={50} rows={10} onChange={updateCode} value={code}></textarea>\r\n  );\r\n};\r\n\r\nexport default Editor;\r\n","import React, { useEffect, useState } from \"react\";\nimport Table from \"./Components/Table\";\nimport { evaluate } from \"./Utils/Evaluation\";\nimport { parse } from \"./Utils/Parser\";\nimport { TruthTable } from \"./Utils/Types\";\nimport { createGenerator } from \"./Utils/ValueSource\";\nimport \"./App.css\";\nimport { useDebouncedState } from \"./Utils/Hooks\";\nimport Editor from \"./Components/Editor\";\n\nfunction App() {\n  const [table, setTable] = useState<TruthTable>();\n  const [error, setError] = useState(\"\");\n  const [code, setCode] = useDebouncedState(\"\", 500);\n\n  const parseExpression = () => {\n    // Code is empty, don't bother trying to run it\n    if (!code) {\n      return;\n    }\n    setError(\"\");\n    try {\n      const { tree, identifiers } = parse(code);\n      const values = createGenerator(identifiers);\n\n      const _table: TruthTable = {\n        columns: identifiers,\n        variants: [],\n      };\n\n      while (!values.done()) {\n        const items = values.next();\n        const result = evaluate(tree, items);\n        _table.variants.push({\n          values: items,\n          result,\n        });\n      }\n\n      setTable(_table);\n    } catch (err) {\n      setError((err as Error).message);\n    }\n  };\n\n  useEffect(parseExpression, [code]);\n\n  return (\n    <div>\n      <div>\n        <span>Operators (in order of precedence):</span>\n        <ul className=\"operator-list\">\n          <li>NOT: !</li>\n          <li>EQ: = (== and === are also permitted)</li>\n          <li>AND: & (&& is also permitted)</li>\n          <li>XOR: ^</li>\n          <li>OR: | (|| is also permitted)</li>\n        </ul>\n        <span>\n          Statements may be grouped with ( ). Anything that isn't an operator,\n          parenthesis, or whitespace will be treated as a variable\n        </span>\n      </div>\n      <div></div>\n      <div>\n        <div>\n          <Editor onChange={setCode} />\n        </div>\n        {error && <span className=\"error\">{error}</span>}\n      </div>\n      <div>{table && <Table table={table} />}</div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\r\n\r\n// Simple hook to debounce state updates\r\nexport const useDebouncedState = <T>(\r\n  initialValue: T | (() => T),\r\n  timeout: number\r\n) => {\r\n  // Timeout handle, initially set to -1\r\n  const handle = React.useRef(-1);\r\n  const [state, setState] = React.useState(initialValue);\r\n\r\n  const debouncer: typeof setState = (state) => {\r\n    // Do we already have a timeout pending?\r\n    if (handle.current > -1) {\r\n      // Clear it\r\n      window.clearTimeout(handle.current);\r\n    }\r\n\r\n    // Create pending state update\r\n    handle.current = window.setTimeout(() => {\r\n      // Clear handle value once timeout has expired\r\n      handle.current = -1;\r\n      setState(state);\r\n    }, timeout);\r\n  };\r\n\r\n  return [state, debouncer] as const;\r\n};\r\n","import { State } from \"./Types\";\r\n\r\nexport const createGenerator = (identifiers: string[]) => {\r\n  // Number of values in each set\r\n  const segments = identifiers.length;\r\n  // 1 << n is the same as 2 ^ n\r\n  const variants = 1 << segments;\r\n  let variant = 0;\r\n  return {\r\n    done() {\r\n      return variant >= variants;\r\n    },\r\n    next() {\r\n      const values: State = {};\r\n      for (let index = 0; index < segments; index++) {\r\n        const name = identifiers[index];\r\n        // Right-shift the current variant by the current index\r\n        // and see if the 1-bit is set. Let's consider this to\r\n        // be false. See below for more details\r\n        const value = (variant >> index) & 1;\r\n        values[name] = !value;\r\n      }\r\n      variant++;\r\n      return values;\r\n    },\r\n  };\r\n};\r\n\r\n/*\r\nThese listings cover each case for the set [a, b, c]\r\n{\r\n  variant: 0,\r\n  a: '0 >> 0 = 0, and 0 & 1 = 0. And finally inverted: 0',\r\n  b: '0 >> 1 = 0, and 0 & 1 = 0. And finally inverted: 0',\r\n  c: '0 >> 2 = 0, and 0 & 1 = 0. And finally inverted: 0'\r\n}\r\n{\r\n  variant: 1,\r\n  a: '1 >> 0 = 1, and 1 & 1 = 1. And finally inverted: 1',\r\n  b: '1 >> 1 = 0, and 0 & 1 = 0. And finally inverted: 0',\r\n  c: '1 >> 2 = 0, and 0 & 1 = 0. And finally inverted: 0'\r\n}\r\n{\r\n  variant: 2,\r\n  a: '2 >> 0 = 2, and 2 & 1 = 0. And finally inverted: 0',\r\n  b: '2 >> 1 = 1, and 1 & 1 = 1. And finally inverted: 1',\r\n  c: '2 >> 2 = 0, and 0 & 1 = 0. And finally inverted: 0'\r\n}\r\n{\r\n  variant: 3,\r\n  a: '3 >> 0 = 3, and 3 & 1 = 1. And finally inverted: 1',\r\n  b: '3 >> 1 = 1, and 1 & 1 = 1. And finally inverted: 1',\r\n  c: '3 >> 2 = 0, and 0 & 1 = 0. And finally inverted: 0'\r\n}\r\n{\r\n  variant: 4,\r\n  a: '4 >> 0 = 4, and 4 & 1 = 0. And finally inverted: 0',\r\n  b: '4 >> 1 = 2, and 2 & 1 = 0. And finally inverted: 0',\r\n  c: '4 >> 2 = 1, and 1 & 1 = 1. And finally inverted: 1'\r\n}\r\n{\r\n  variant: 5,\r\n  a: '5 >> 0 = 5, and 5 & 1 = 1. And finally inverted: 1',\r\n  b: '5 >> 1 = 2, and 2 & 1 = 0. And finally inverted: 0',\r\n  c: '5 >> 2 = 1, and 1 & 1 = 1. And finally inverted: 1'\r\n}\r\n{\r\n  variant: 6,\r\n  a: '6 >> 0 = 6, and 6 & 1 = 0. And finally inverted: 0',\r\n  b: '6 >> 1 = 3, and 3 & 1 = 1. And finally inverted: 1',\r\n  c: '6 >> 2 = 1, and 1 & 1 = 1. And finally inverted: 1'\r\n}\r\n{\r\n  variant: 7,\r\n  a: '7 >> 0 = 7, and 7 & 1 = 1. And finally inverted: 1',\r\n  b: '7 >> 1 = 3, and 3 & 1 = 1. And finally inverted: 1',\r\n  c: '7 >> 2 = 1, and 1 & 1 = 1. And finally inverted: 1'\r\n}\r\n*/\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}